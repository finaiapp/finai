---
phase: 02-account-lifecycle
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - server/api/plaid/items/[itemId].delete.ts
  - server/utils/plaid-accounts.ts
  - app/components/plaid/DisconnectConfirm.vue
  - app/components/plaid/AccountsList.vue
  - app/pages/dashboard/accounts.vue
autonomous: true

must_haves:
  truths:
    - "DELETE /api/plaid/items/:itemId calls plaidClient.itemRemove() then cascade-deletes from local DB"
    - "Disconnect handles already-invalid tokens gracefully (still cleans up local data)"
    - "User sees a confirmation modal before disconnect proceeds"
    - "After disconnect, the institution and its accounts disappear from the accounts list"
    - "Only the item owner can disconnect (userId check on every operation)"
  artifacts:
    - path: "server/api/plaid/items/[itemId].delete.ts"
      provides: "DELETE endpoint for disconnecting a Plaid item"
      contains: "itemRemove"
    - path: "server/utils/plaid-accounts.ts"
      provides: "deletePlaidItem and getPlaidItemByItemId utilities"
      contains: "deletePlaidItem"
    - path: "app/components/plaid/DisconnectConfirm.vue"
      provides: "UModal confirmation dialog for disconnect"
      contains: "UModal"
    - path: "app/components/plaid/AccountsList.vue"
      provides: "Updated accounts list with disconnect button per institution"
      contains: "DisconnectConfirm"
  key_links:
    - from: "server/api/plaid/items/[itemId].delete.ts"
      to: "server/utils/plaid-accounts.ts"
      via: "deletePlaidItem and getPlaidItemAccessToken"
      pattern: "deletePlaidItem"
    - from: "server/api/plaid/items/[itemId].delete.ts"
      to: "server/utils/plaid.ts"
      via: "plaidClient.itemRemove and extractPlaidError"
      pattern: "plaidClient\\.itemRemove"
    - from: "app/components/plaid/AccountsList.vue"
      to: "app/components/plaid/DisconnectConfirm.vue"
      via: "component usage"
      pattern: "PlaidDisconnectConfirm|DisconnectConfirm"
---

<objective>
Account disconnect flow with API endpoint, UI confirmation, and cascading cleanup.

Purpose: Allow the user to remove a linked bank account. This revokes the access token at Plaid, then cascade-deletes the plaid_items row (which automatically removes associated plaid_accounts and sync_cursors rows via ON DELETE CASCADE).
Output: A DELETE API endpoint, a server utility for item deletion, a confirmation modal component, and an updated accounts list with disconnect buttons.
</objective>

<execution_context>
@/home/ollie/.claude/get-shit-done/workflows/execute-plan.md
@/home/ollie/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-account-lifecycle/02-RESEARCH.md
@server/utils/plaid-accounts.ts
@server/utils/plaid.ts
@server/api/plaid/link-token.post.ts
@app/components/plaid/AccountsList.vue
@app/components/plaid/ConnectBank.vue
@app/components/transactions/TransactionDeleteConfirm.vue
@app/pages/dashboard/accounts.vue
</context>

<tasks>

<task type="auto">
  <name>Task 1: Server utility and API endpoint for item disconnect</name>
  <files>server/utils/plaid-accounts.ts, server/api/plaid/items/[itemId].delete.ts</files>
  <action>
Add two new functions to `server/utils/plaid-accounts.ts`:

1. `getPlaidItemByItemId(itemId: string, userId: number)` -- fetches a plaid_items row by Plaid's itemId string with ownership check. Returns the row (id, itemId, institutionName, status) or null. This is needed so the API can verify the item exists and belongs to the user before attempting removal.

2. `deletePlaidItem(itemId: string, userId: number): Promise<boolean>` -- deletes a plaid_items row by Plaid's itemId string with ownership check. Uses `db.delete(plaidItems).where(and(eq(plaidItems.itemId, itemId), eq(plaidItems.userId, userId))).returning({ id: plaidItems.id })`. Returns true if a row was deleted, false otherwise. ON DELETE CASCADE handles plaid_accounts and sync_cursors automatically.

Create `server/api/plaid/items/[itemId].delete.ts`:
- `requireUserSession(event)` for auth
- `checkRateLimit(apiRateLimiter, ...)` for rate limiting (follow existing pattern from link-token.post.ts)
- Get `itemId` from `getRouterParam(event, 'itemId')`
- Validate itemId is a non-empty string, throw 400 if missing
- Call `getPlaidItemAccessToken(itemId, session.user.id)` to get the decrypted access token (this also verifies ownership -- throws if not found)
- Wrap in try/catch: call `plaidClient.itemRemove({ access_token: accessToken })`
- In the catch: extract error with `extractPlaidError(error)`. If statusCode is 400 (token already invalid), log a warning but continue with local cleanup. For other errors, re-throw with `createError()`.
- Call `deletePlaidItem(itemId, session.user.id)` to remove from local DB
- Return `{ success: true }`
  </action>
  <verify>
Run `bun run build` to confirm no TypeScript errors. Verify the file is at the correct Nitro route path (server/api/plaid/items/[itemId].delete.ts maps to DELETE /api/plaid/items/:itemId).
  </verify>
  <done>DELETE /api/plaid/items/:itemId endpoint exists. It calls itemRemove at Plaid, handles already-invalid tokens, then cascade-deletes local data. Server utils include deletePlaidItem and getPlaidItemByItemId.</done>
</task>

<task type="auto">
  <name>Task 2: Disconnect confirmation modal component</name>
  <files>app/components/plaid/DisconnectConfirm.vue</files>
  <action>
Create `app/components/plaid/DisconnectConfirm.vue` following the pattern from `app/components/transactions/TransactionDeleteConfirm.vue`:

Props:
- `open: boolean` -- controls modal visibility
- `institutionName: string` -- name of the institution being disconnected
- `loading: boolean` -- disables buttons and shows spinner on confirm button

Emits:
- `confirm` -- user confirmed disconnect
- `cancel` -- user cancelled

Template:
- `UModal` with `:open="open"` and `@close="emit('cancel')"`
- Header slot: "Disconnect {institutionName}?"
- Body: Warning text explaining that all accounts from this institution will be removed. Mention that any previously synced transactions will be preserved (anticipating Phase 3).
- Footer slot: flex row with Cancel (UButton variant="ghost", disabled when loading) and Disconnect (UButton color="error", :loading prop)
  </action>
  <verify>
Run `bun run build` to confirm no TypeScript errors.
  </verify>
  <done>DisconnectConfirm modal component exists with institution name display, warning text, and cancel/confirm buttons with loading state.</done>
</task>

<task type="auto">
  <name>Task 3: Add disconnect button to AccountsList and wire up flow</name>
  <files>app/components/plaid/AccountsList.vue, app/pages/dashboard/accounts.vue</files>
  <action>
Update `app/components/plaid/AccountsList.vue`:

1. Add state refs:
   - `disconnectingItemId: ref<string | null>(null)` -- tracks which item is being disconnected (null = modal closed)
   - `disconnectInstitutionName: ref<string>('')` -- institution name for the modal
   - `disconnectLoading: ref<boolean>(false)` -- loading state during API call

2. Add a "Disconnect" button to each institution group header (inside the UCard #header slot, right side of the flex row). Use UButton with:
   - `variant="ghost"` `color="error"` `size="xs"`
   - Icon: `i-lucide-unplug`
   - Label: "Disconnect"
   - `@click` sets `disconnectingItemId` to the group's first account's plaidItemId (need to also store the Plaid itemId -- see below) and `disconnectInstitutionName` to the group name

3. The PlaidAccount interface needs the Plaid `itemId` string (not just `plaidItemId` which is the DB id). Update the interface to include `itemId: string`. This requires updating the server's `getUserPlaidAccounts()` in plaid-accounts.ts to also select `plaidItems.itemId` (the Plaid identifier).

4. Add the `PlaidDisconnectConfirm` component at the bottom of the template:
   - `:open="disconnectingItemId !== null"`
   - `:institution-name="disconnectInstitutionName"`
   - `:loading="disconnectLoading"`
   - `@cancel` resets disconnectingItemId to null
   - `@confirm` calls a `handleDisconnect()` function

5. `handleDisconnect()` function:
   - Set `disconnectLoading = true`
   - Call `$fetch(`/api/plaid/items/${disconnectingItemId}`, { method: 'DELETE' })`
   - On success: reset `disconnectingItemId` to null, call `fetchAccounts()` to refresh the list
   - On error: set `error.value` via `handleApiError(err)`
   - Finally: `disconnectLoading = false`

6. To get the Plaid itemId for each institution group, group accounts must carry the itemId. Update `groupedAccounts` computed to also track the `itemId` on each group:
   ```typescript
   interface InstitutionGroup {
     name: string
     itemId: string  // Plaid's item_id for disconnect
     accounts: PlaidAccount[]
   }
   ```
   Use the first account's `itemId` field for the group's itemId (all accounts in a group share the same item).

Update `server/utils/plaid-accounts.ts` `getUserPlaidAccounts()`:
- Add `itemId: plaidItems.itemId` to the select fields so the client has access to the Plaid item_id string for disconnect API calls.
  </action>
  <verify>
Run `bun run build` to confirm no TypeScript errors. Verify the disconnect button appears in the institution group header. Verify the modal opens on click and the disconnect flow completes.
  </verify>
  <done>AccountsList shows a Disconnect button per institution group. Clicking it opens a confirmation modal. Confirming calls the DELETE API, removes the item, and refreshes the account list. The Plaid itemId is available in the account data for API calls.</done>
</task>

</tasks>

<verification>
- `bun run build` passes with no TypeScript errors
- DELETE /api/plaid/items/:itemId endpoint exists and requires auth
- DisconnectConfirm modal component renders with institution name
- AccountsList shows disconnect button per institution group
- Disconnect flow: button -> modal -> confirm -> API call -> list refresh
</verification>

<success_criteria>
Phase 2 success criterion #1 is met: User can disconnect a linked bank account and it disappears from the dashboard. The API revokes the token at Plaid before cleaning up local data. Already-invalid tokens are handled gracefully. Ownership is verified on every operation.
</success_criteria>

<output>
After completion, create `.planning/phases/02-account-lifecycle/02-01-SUMMARY.md`
</output>
